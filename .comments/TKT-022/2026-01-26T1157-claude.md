---
author: Claude
timestamp: 2026-01-26T11:57:31.880Z
---
## Expanded Tradeoffs for Write Approaches

### Option A: Route writes through MCP server

**How it works:**
Client tRPC → MCP HTTP endpoint → MCP writes to local clone → git commit → git push

**Pros:**
- Single source of truth for write logic
- MCP already handles SSE events for realtime updates
- Proper commit authorship (MCP knows user context)
- Works for Claude Code and web client identically
- No new code in client - just call existing MCP endpoints

**Cons:**
- Extra network hop (client → server → MCP → GitHub)
- MCP must be running/reachable for web client writes
- Latency: ~200-500ms added vs direct GitHub API
- Coupling: web client depends on MCP availability

**Best for:** Simpler architecture, consistency with Claude Code usage

---

### Option B: Client-side git push (isomorphic-git)

**How it works:**
Browser isomorphic-git → write to IndexedDB clone → git commit → git push via `/api/git/` proxy → GitHub

**Pros:**
- Writes happen locally first (optimistic, fast UI)
- Works offline (commit locally, push when online)
- Browser git clone stays in sync automatically
- No MCP dependency for web client
- True "local-first" architecture

**Cons:**
- Need to implement git push in browser (auth token handling)
- Merge conflicts more complex to handle client-side
- Duplicate write logic (client + MCP both need it)
- `/api/git/` proxy needs to handle push auth
- Commit authorship: need user's git identity in browser

**Best for:** Local-first UX, offline support, independence from MCP

---

### Option C: Hybrid approach

**How it works:**
- Simple writes (single file): client-side git push
- Complex operations (multi-file, migrations): route through MCP

**Pros:**
- Fast path for common operations
- MCP for complex orchestration
- Flexibility

**Cons:**
- Most complex to implement and maintain
- Two code paths to test
- Inconsistent behavior possible

---

## Recommendation

**Start with Option A (MCP routing)** because:
1. MCP write logic already exists and works
2. Simpler to implement (remove client code, add tRPC→MCP calls)
3. SSE realtime updates already wired up
4. Can evolve to Option B later if offline/latency matters

Option B is better long-term for a true local-first app, but Option A gets consistency now with minimal effort.
