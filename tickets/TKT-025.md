---
status: in_progress
priority: medium
created: 2026-01-28
---
# TKT-025: Migrate MCP server from isomorphic-git to native git

## Problem

The MCP server currently uses `isomorphic-git` for all git operations. This was likely chosen for simplicity, but isomorphic-git is designed for environments where native git isn't available (browsers, edge functions). On the server, this creates unnecessary limitations:

1. **No worktree support** - Can't isolate concurrent sessions working on the same repo
2. **Commit-per-write** - Currently every write/delete commits and pushes immediately, creating noisy history
3. **Missing features** - Less mature than native git, missing edge case handling

## Proposed Solution

Replace isomorphic-git with native git (shell out directly or use `simple-git` wrapper). This enables:

### 1. Worktree-based Session Isolation

Each active session gets its own worktree, allowing true parallel operations:

```
git worktree add /tmp/sessions/{sessionId} -b session/{sessionId}
# ... writes happen in isolated worktree ...
# on completion: merge, push, cleanup
git worktree remove /tmp/sessions/{sessionId}
```

### 2. Batched Commits

Writes accumulate in the session worktree, single commit at session end instead of per-operation.

## Key Challenge: Session Lifecycle

MCP is stateless request/response - how do we know when a "completion" starts and ends?

Options:
- **Explicit tools**: Add `begin_transaction` / `commit_transaction` tools Claude must call
- **Implicit timeout**: Create worktree on first write, auto-commit after N seconds of inactivity  
- **Completion hooks**: If the MCP client signals completion boundaries, hook into that
- **Hybrid**: Auto-commit on timeout, but allow explicit commit for immediate push

The explicit approach is cleanest but requires Claude to remember. Timeout is more forgiving but needs careful handling of "completion still in progress" cases.

## Investigation: Session Boundary Detection

**Status: Gathering data**

Added logging in commit `7d6bef1` to understand MCP client behavior.

### Findings So Far

From initial logs (single completion with 4 tool calls):

1. **No X-Session-Id header** - Claude Code doesn't send one; falls back to `user-{userId}`

2. **`_meta.claudecode/toolUseId`** - Each tool call includes a unique ID:
   ```
   {"claudecode/toolUseId":"toolu_012hz8tr2GQ34GeA4wPXDGDC"}
   ```
   These are Anthropic API tool_use IDs, unique per tool call (not per completion).

3. **Request IDs increment** - jsonrpc IDs were 12, 13, 14, 15 within one completion. Need to check if these reset between completions.

4. **Timing within completion** - 4-12 second gaps between tool calls within a single completion.

### Questions Still Open

- What's the timing gap between completions? (> 30s would trigger timeout detection)
- Do request IDs reset between completions?
- Is `initialize` called between completions or only on first connection?
- Is there any pattern in `toolUseId` that groups calls by completion?

## Additional Considerations

- Cleanup for abandoned sessions / unexpected termination
- Merge conflict handling if main moves during a session
- Migration path - can we do this incrementally or is it all-or-nothing?

## Files to Change

- `mcp/src/operations/repos.ts` - Core git operations
- `mcp/src/operations/files.ts` - Write/delete operations  
- `mcp/src/operations/tickets.ts` - Ticket CRUD
- `mcp/src/operations/boards.ts` - Board operations
- `mcp/src/operations/git.ts` - Commit/push handlers
- `mcp/src/session.ts` - Session management (add worktree tracking)
