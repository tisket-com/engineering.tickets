---
status: in_progress
priority: medium
created: 2026-01-28
---
# TKT-025: Migrate MCP server from isomorphic-git to native git

## Problem

The MCP server currently uses `isomorphic-git` for all git operations. This was likely chosen for simplicity, but isomorphic-git is designed for environments where native git isn't available (browsers, edge functions). On the server, this creates unnecessary limitations:

1. **No worktree support** - Can't isolate concurrent sessions working on the same repo
2. **Commit-per-write** - Currently every write/delete commits and pushes immediately, creating noisy history
3. **Missing features** - Less mature than native git, missing edge case handling

## Research

See [git-server-patterns.md](../../git-overview/git-server-patterns.md) for detailed analysis of how production services handle git operations:

- **GitLab Gitaly** - RPC over native git, process caching
- **Soft Serve** - Hook system, SQLite for metadata
- **simple-git** - Built-in scheduler with concurrency control
- **Dugite/GitHub Desktop** - GIT_ASKPASS for credentials

## Proposed Solution

Replace isomorphic-git with `simple-git`. This library provides:

- **Built-in scheduler** - Configurable `maxConcurrentProcesses` (default 2)
- **Error handling** - Fatal errors purge the queue to prevent cascading failures
- **Plugin system** - Hooks for auth, logging, spawn customization
- **Full worktree support** - Native git commands

### Session-Worktree Mapping

Each user gets a worktree, created lazily on first write:

```
1. First write operation for user
   └─► git worktree add /tmp/sessions/{userId} -b session/{userId}

2. Subsequent writes (same user)
   └─► Reuse existing worktree, stage changes

3. Commit (explicit or timeout)
   └─► Commit, merge to main, push, cleanup worktree
```

This means:
- Worktree persists until commit (explicit or timeout)
- Same user's subsequent writes reuse the existing worktree
- Different users get different worktrees (isolation)

### Hybrid Commit Strategy

**Primary: Explicit `commit_changes` tool**
- Claude calls this after completing write operations
- Tool description guides usage: "Call after making write operations to commit and push changes"
- Provides immediate feedback - changes pushed as soon as Claude is done

**Fallback: Timeout-based auto-commit**
- Debounced timer per session - reset on each write, fires after 15s idle
- No separate background process needed
- Safety net for: forgotten commits, completion ending unexpectedly, crashes
- 15 seconds chosen because gaps within a completion are 4-12 seconds

```typescript
class SessionCommitManager {
  private timers = new Map<string, NodeJS.Timeout>();
  
  scheduleCommit(sessionId: string, delay = 15_000) {
    // Cancel existing timer (debounce)
    const existing = this.timers.get(sessionId);
    if (existing) clearTimeout(existing);
    
    // Schedule new timer
    const timer = setTimeout(() => {
      this.commitAndPush(sessionId);
      this.timers.delete(sessionId);
    }, delay);
    
    this.timers.set(sessionId, timer);
  }
}
```

### Credentials via GIT_ASKPASS

Use GIT_ASKPASS for secure token handling (pattern from Dugite/GitHub Desktop):

```typescript
function createAskpassScript(token: string): string {
  const script = join(tmpdir(), `askpass-${Date.now()}.sh`);
  writeFileSync(script, `#!/bin/sh\necho "${token}"\n`);
  chmodSync(script, 0o700);
  return script;
}

// Usage with simple-git
await git.env('GIT_ASKPASS', createAskpassScript(token)).push();
```

Benefits:
- No tokens in command line args (visible in `ps`)
- No tokens stored in git config
- Script deleted after use

### `commit_changes` Flow

```
1. Commit staged changes in session worktree
2. Fetch latest from origin/main
3. Merge origin/main into session branch
4. If conflicts:
   → Return conflict details to Claude
   → Claude resolves and calls commit_changes again
5. If clean:
   → Checkout main in primary clone
   → Merge session branch (fast-forward)
   → Push to origin
   → Remove worktree and session branch
   → Return success with commit SHA
```

### Tool Response Examples

**Success:**
```json
{
  "success": true,
  "commit": "abc123f",
  "message": "Committed and pushed 3 files",
  "files": ["tickets/TKT-025.md", "README.md", "docs/api.md"]
}
```

**Conflict:**
```json
{
  "success": false,
  "conflict": true,
  "files": ["tickets/TKT-025.md"],
  "message": "Merge conflict in tickets/TKT-025.md. Resolve and call commit_changes again."
}
```

## Investigation Summary

Logged MCP requests to understand session boundaries. Key findings:

| What | Finding |
|------|---------|
| X-Session-Id header | Not sent by Claude Code; falls back to user ID |
| `_meta.claudecode/toolUseId` | Unique per tool call, not per completion |
| jsonrpc request IDs | Increment continuously, don't reset between completions |
| Gaps within completion | 4-12 seconds |
| Gaps between completions | Minutes (user think time) |
| Headers | `mcp-protocol-version: 2024-11-05`, `user-agent: claude-code/2.1.22` |
| Notifications | None observed |

**Conclusion:** No explicit completion boundary signals from client. Timeout detection works reliably as a fallback.

## Implementation Tasks

1. **Replace isomorphic-git with simple-git**
   - Add `simple-git` dependency
   - Configure scheduler: `maxConcurrentProcesses: 4`
   - Update all git operations in `mcp/src/operations/`

2. **Add worktree management**
   - Create worktree lazily on first write per user
   - Track active worktrees in session state
   - Cleanup on commit or timeout

3. **Add credentials handling**
   - Implement GIT_ASKPASS script creation
   - Clean up scripts after use
   - Pass via simple-git's `.env()` method

4. **Add `commit_changes` tool**
   - Commits staged changes in session worktree
   - Fetches and merges latest main (detects conflicts)
   - If clean: merges to main, pushes to origin
   - Returns conflict details if merge fails
   - Tool description instructs Claude when to call it

5. **Add timeout-based auto-commit**
   - Debounced timer per session (Map of userId → setTimeout handle)
   - Reset timer on each write operation
   - Triggers commit after 15 seconds of inactivity
   - Same logic as explicit commit_changes
   - On conflict: leaves changes staged, notifies on next request

6. **Handle edge cases**
   - Merge conflicts: return to Claude for resolution
   - Abandoned sessions: periodic cleanup of stale worktrees (e.g., older than 1 hour)
   - Multiple concurrent users on same repo: worktrees provide isolation

## Files to Change

- `mcp/src/operations/repos.ts` - Replace isomorphic-git with simple-git
- `mcp/src/operations/files.ts` - Stage changes instead of immediate commit
- `mcp/src/operations/tickets.ts` - Stage changes instead of immediate commit
- `mcp/src/operations/boards.ts` - Stage changes instead of immediate commit
- `mcp/src/operations/git.ts` - New commit_changes handler, worktree management
- `mcp/src/session.ts` - Track worktree state, pending changes, commit timers
- `mcp/src/tools/index.ts` - Add commit_changes tool definition
- New: `mcp/src/lib/worktree.ts` - Worktree lifecycle management
- New: `mcp/src/lib/askpass.ts` - GIT_ASKPASS script creation/cleanup
