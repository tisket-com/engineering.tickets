---
status: in_progress
priority: medium
created: 2026-01-28
---
# TKT-025: Migrate MCP server from isomorphic-git to native git

## Problem

The MCP server currently uses `isomorphic-git` for all git operations. This was likely chosen for simplicity, but isomorphic-git is designed for environments where native git isn't available (browsers, edge functions). On the server, this creates unnecessary limitations:

1. **No worktree support** - Can't isolate concurrent sessions working on the same repo
2. **Commit-per-write** - Currently every write/delete commits and pushes immediately, creating noisy history
3. **Missing features** - Less mature than native git, missing edge case handling

## Proposed Solution

Replace isomorphic-git with native git (shell out directly or use `simple-git` wrapper). This enables:

### 1. Worktree-based Session Isolation

Each active session gets its own worktree, allowing true parallel operations:

```
git worktree add /tmp/sessions/{sessionId} -b session/{sessionId}
# ... writes happen in isolated worktree ...
# on completion: merge, push, cleanup
git worktree remove /tmp/sessions/{sessionId}
```

### 2. Batched Commits

Writes accumulate in the session worktree, single commit at session end instead of per-operation.

## Key Challenge: Session Lifecycle

MCP is stateless request/response - how do we know when a "completion" starts and ends?

Options:
- **Explicit tools**: Add `begin_transaction` / `commit_transaction` tools Claude must call
- **Implicit timeout**: Create worktree on first write, auto-commit after N seconds of inactivity  
- **Completion hooks**: If the MCP client signals completion boundaries, hook into that
- **Hybrid**: Auto-commit on timeout, but allow explicit commit for immediate push

The explicit approach is cleanest but requires Claude to remember. Timeout is more forgiving but needs careful handling of "completion still in progress" cases.

## Investigation: Session Boundary Detection

**Status: Awaiting logs**

Added logging in commit `7d6bef1` to understand MCP client behavior:

- `X-Session-Id` header - what values clients send (or if they don't)
- Request timing patterns - gaps between requests that might indicate completion boundaries
- `initialize` method calls - might indicate new connections
- Unknown methods - catch notifications we're not handling
- Extra params in `tools/call` - metadata we might be ignoring

Questions to answer from logs:
1. Does Claude Code send a consistent `X-Session-Id`? Per-completion? Per-conversation?
2. Is there a timing pattern that reliably indicates completion end?
3. Are there any MCP notifications/methods we're not handling that signal boundaries?

## Additional Considerations

- Cleanup for abandoned sessions / unexpected termination
- Merge conflict handling if main moves during a session
- Migration path - can we do this incrementally or is it all-or-nothing?

## Files to Change

- `mcp/src/operations/repos.ts` - Core git operations
- `mcp/src/operations/files.ts` - Write/delete operations  
- `mcp/src/operations/tickets.ts` - Ticket CRUD
- `mcp/src/operations/boards.ts` - Board operations
- `mcp/src/operations/git.ts` - Commit/push handlers
- `mcp/src/session.ts` - Session management (add worktree tracking)
