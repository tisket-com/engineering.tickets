---
status: in_progress
priority: medium
created: 2026-01-28
---
# TKT-025: Migrate MCP server from isomorphic-git to native git

## Problem

The MCP server currently uses `isomorphic-git` for all git operations. This was likely chosen for simplicity, but isomorphic-git is designed for environments where native git isn't available (browsers, edge functions). On the server, this creates unnecessary limitations:

1. **No worktree support** - Can't isolate concurrent sessions working on the same repo
2. **Commit-per-write** - Currently every write/delete commits and pushes immediately, creating noisy history
3. **Missing features** - Less mature than native git, missing edge case handling

## Proposed Solution

Replace isomorphic-git with native git (shell out directly or use `simple-git` wrapper). This enables:

### 1. Worktree-based Session Isolation

Each active session gets its own worktree, allowing true parallel operations:

```
git worktree add /tmp/sessions/{sessionId} -b session/{sessionId}
# ... writes happen in isolated worktree ...
# on completion: merge, push, cleanup
git worktree remove /tmp/sessions/{sessionId}
```

### 2. Batched Commits

Writes accumulate in the session worktree, single commit at session end instead of per-operation.

## Key Challenge: Session Lifecycle

MCP is stateless request/response - how do we know when a "completion" starts and ends?

### Confirmed: Timeout-based Detection Works

From logging analysis, the pattern is clear:

| Scenario | Gap Between Requests |
|----------|---------------------|
| Within completion | 4-12 seconds |
| Between completions | Minutes (user think time + processing) |

A 30-second timeout threshold reliably detects completion boundaries.

### Implementation Approach

1. **On first write after gap > threshold:**
   - Commit/push any pending changes from previous completion
   - Create new worktree for this completion
2. **Writes accumulate** in session worktree (no immediate commit)
3. **Next completion** triggers commit/push/cleanup of previous

## Investigation: Session Boundary Detection

### Findings

1. **No X-Session-Id header** - Claude Code doesn't send one; falls back to `user-{userId}`

2. **`_meta.claudecode/toolUseId`** - Each tool call includes a unique Anthropic API tool_use ID:
   ```
   {"claudecode/toolUseId":"toolu_015CVYdUuqJ4bPynVZpziFRi"}
   ```
   Unique per tool call, not per completion.

3. **Request IDs don't reset** - jsonrpc IDs increment continuously across completions (12-15, then 16...)

4. **Timeout detection works** - Gap of 416 seconds between completions correctly triggered `POTENTIAL NEW COMPLETION` log

### Additional Logging Added

Commit `a61d97d` adds comprehensive logging:
- All HTTP headers (looking for client version, user-agent, MCP-specific headers)
- Full request body structure
- JSON-RPC notifications (MCP spec mentions `notifications/initialized`, `notifications/cancelled`)

Awaiting logs to see if there's additional metadata we're missing.

## Additional Considerations

- Cleanup for abandoned sessions / unexpected termination
- Merge conflict handling if main moves during a session
- Migration path - can we do this incrementally or is it all-or-nothing?

## Files to Change

- `mcp/src/operations/repos.ts` - Core git operations (replace isomorphic-git)
- `mcp/src/operations/files.ts` - Write/delete operations  
- `mcp/src/operations/tickets.ts` - Ticket CRUD
- `mcp/src/operations/boards.ts` - Board operations
- `mcp/src/operations/git.ts` - Commit/push handlers
- `mcp/src/session.ts` - Session management (add worktree tracking)
