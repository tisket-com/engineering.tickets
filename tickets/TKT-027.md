---
status: open
priority: high
created: 2026-01-29
---
# TKT-027: Client Service Desk Architecture - Threads & Email Gateway

## Overview

Architecture decisions for how external clients interact with Tisket as a service desk. This covers the client-facing "threads" model, email integration, and how it bridges to internal ticketing.

---

## Key Decisions

### 1. Threads vs Tickets (Two Distinct Concepts)

**Decision:** Client-facing interactions are "threads" (simple), internal work is "tickets" (complex).

| Threads (Client-Facing) | Tickets (Internal) |
|-------------------------|---------------------|
| Subject + status + messages | Full workflow |
| Open, in_progress, resolved, closed | Priority, SLA, assignee |
| No internal notes | Internal notes, discussions |
| Simple conversation | Links to other tickets, metadata |

**Rationale:** Clients don't need ticketing complexity. They need a conversation with status. All internal complexity stays in `.tickets` repos.

### 2. Storage Format: HTML (Not Markdown)

**Decision:** Store thread messages as HTML, not markdown.

**Rationale:**
- Emails arrive as HTML
- HTML→Markdown conversion is lossy and complex
- Would require AI to extract actual content from email HTML (quoted replies, signatures, etc.)
- If we're building a UI anyway, it can render HTML
- Git's text-diff benefits don't apply to HTML blobs

### 3. Storage Backend: Database (Not Git)

**Decision:** Threads stored in a database, not git repos.

**Rationale:**
- Git benefits (version history, offline, distributed) don't add much for append-only conversations
- Threads are simple CRUD operations
- Real-time updates easier with database
- HTML content makes git diffs meaningless anyway
- Database is the right tool for this job

**Note:** Internal `.tickets` repos remain git-based (markdown, version history matters).

### 4. Email Integration: Webhook Model

**Decision:** Use email provider webhooks (Postmark, SendGrid, etc.) for inbound email.

**Rejected alternatives:**
- Platform-provided address (`@platform.com`) - unprofessional
- Email forwarding - breaks SPF/DKIM, adds latency
- IMAP/OAuth polling - complex setup, polling delays

**Webhook advantages:**
- Real-time (no polling)
- Email parsing handled by provider
- Low ops burden
- Works with custom domains

### 5. Email Threading Mechanism

**Implementation:**
- Outbound emails include thread ID in subject: `[THD-001] Subject`
- Generate unique `Message-ID` header, store in database
- Inbound replies matched by:
  1. `In-Reply-To` header → lookup original message
  2. Parse `[THD-xxx]` from subject
  3. Watermark/token in body (fallback)

**Security:**
- Tokens in thread references prevent guessing
- SPF/DKIM/DMARC verify sending domain
- New threads can require known contacts only

### 6. Custom Domain Support (Multi-tenant)

**Decision:** Support customers using their own email domains.

**Requirements per customer:**
- MX record pointing to email provider
- SPF record authorizing provider
- DKIM CNAME for signatures
- Domain verification in provider

**Implementation:**
- Tenant identification via `To` address on inbound
- Outbound sends `From` customer's domain
- Database scoped by tenant

**Recommendation:** Start with single domain, add custom domains as premium feature.

### 7. No AI Intermediary for Email

**Decision:** Email gateway has no AI processing. Raw email → thread storage.

**The MCP is the bridge:**
- Agents read threads via MCP
- Agents create/update internal tickets
- Agents write replies to threads
- MCP handles the mapping, not the email gateway

---

## Architecture Diagram

```
CLIENT SIDE

  Client        Thread API       Thread Storage
  (Email)                        (Database, HTML)
     │                                  │
     │           Email Gateway ◄────────┘
     └──────────▶ (Webhooks)
                      │
                      ▼
              Email Provider
              (Postmark, SendGrid)
```

```
PROVIDER SIDE

  Agent ◄────▶ MCP ◄────▶ .tickets repo (internal, git)
                │
                │ reads/writes threads
                ▼
         Thread Storage (shared access)
```

---

## Data Model

### Threads (Database)

```sql
CREATE TABLE tenants (
  id              TEXT PRIMARY KEY,
  name            TEXT,
  inbound_domain  TEXT UNIQUE,   -- support.clientcorp.com
  outbound_domain TEXT           -- clientcorp.com
);

CREATE TABLE threads (
  id            TEXT PRIMARY KEY,   -- THD-001
  tenant_id     TEXT REFERENCES tenants(id),
  subject       TEXT,
  status        TEXT,               -- open, in_progress, resolved, closed
  client_email  TEXT,
  client_name   TEXT,
  created_at    TIMESTAMP,
  updated_at    TIMESTAMP
);

CREATE TABLE messages (
  id            TEXT PRIMARY KEY,
  thread_id     TEXT REFERENCES threads(id),
  message_id    TEXT,               -- Email Message-ID header
  direction     TEXT,               -- inbound, outbound
  from_address  TEXT,
  body_html     TEXT,
  created_at    TIMESTAMP
);

CREATE TABLE attachments (
  id            TEXT PRIMARY KEY,
  message_id    TEXT REFERENCES messages(id),
  filename      TEXT,
  content_type  TEXT,
  storage_path  TEXT                -- S3/R2 path
);
```

### Internal Ticket Link

```yaml
# In engineering.tickets/TKT-042.md
---
status: in_progress
priority: high
assignee: "@sarah"
client_thread:
  tenant: clientcorp
  thread_id: THD-001
---
```

---

## MCP Tools Needed

```typescript
// Thread operations
list_threads(tenant_id, status?)
get_thread(thread_id)
reply_to_thread(thread_id, body)
update_thread_status(thread_id, status)

// Linking
link_thread_to_ticket(thread_id, ticket_id)
get_ticket_for_thread(thread_id)
```

---

## Implementation Phases

### Phase 1: Core Email Gateway
- Webhook endpoint for inbound email
- Thread/message storage (database)
- Outbound email sending
- Basic threading (subject line parsing)

### Phase 2: MCP Integration
- MCP tools to read/write threads
- Link threads to internal tickets
- Agent workflow for responding

### Phase 3: Client Portal (Optional)
- Web UI for clients to view their threads
- Direct message submission (no email)
- File upload/download

### Phase 4: Multi-tenant / Custom Domains
- Per-tenant configuration
- Custom domain onboarding flow
- Domain verification

---

## Open Questions

1. **Attachment storage:** S3/R2 vs database blobs?
2. **Thread portal:** Build custom or use existing solution?
3. **Real-time:** WebSockets for live thread updates?
4. **Email provider:** Postmark vs SendGrid vs others?

---

## References

- ServiceNow email threading model
- Jira Service Management customer portal
- Postmark inbound webhook documentation
