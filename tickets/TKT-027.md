---
status: open
priority: high
created: 2026-01-29
updated: 2026-01-29
---
# TKT-027: Client Service Desk Architecture - Threads & Email Gateway

## Overview

Architecture decisions for how external clients interact with Tisket as a service desk. This covers the client-facing "threads" model, email integration, and how it bridges to internal ticketing.

---

## Key Decisions

### 1. Threads vs Tickets (Two Distinct Concepts)

**Decision:** Client-facing interactions are "threads" (simple), internal work is "tickets" (complex).

| Threads (Client-Facing) | Tickets (Internal) |
|-------------------------|---------------------|
| Subject + status + messages | Full workflow |
| Open, in_progress, resolved, closed | Priority, SLA, assignee |
| No internal notes | Internal notes, discussions |
| Simple conversation | Links to other tickets, metadata |

**Rationale:** Clients don't need ticketing complexity. They need a conversation with status. All internal complexity stays in `.tickets` repos.

### 2. Storage Format: HTML (Not Markdown)

**Decision:** Store thread messages as HTML, not markdown.

**Rationale:**
- Emails arrive as HTML
- HTML→Markdown conversion is lossy and complex
- Would require AI to extract actual content from email HTML (quoted replies, signatures, etc.)
- If we're building a UI anyway, it can render HTML
- Git's text-diff benefits don't apply to HTML blobs

### 3. Storage Backend: Database (Not Git)

**Decision:** Threads stored in a database, not git repos.

**Rationale:**
- Git benefits (version history, offline, distributed) don't add much for append-only conversations
- Threads are simple CRUD operations
- Real-time updates easier with database
- HTML content makes git diffs meaningless anyway
- Database is the right tool for this job

**Note:** Internal `.tickets` repos remain git-based (markdown, version history matters).

### 4. Email Integration: Webhook Model

**Decision:** Use email provider webhooks (Postmark, SendGrid, etc.) for inbound email.

**Rejected alternatives:**
- Platform-provided address (`@platform.com`) - unprofessional
- Email forwarding - breaks SPF/DKIM, adds latency
- IMAP/OAuth polling - complex setup, polling delays

**Webhook advantages:**
- Real-time (no polling)
- Email parsing handled by provider
- Low ops burden
- Works with custom domains

### 5. Email Threading Mechanism

**Implementation:**
- Outbound emails include thread ID in subject: `[THD-001] Subject`
- Generate unique `Message-ID` header, store in database
- Inbound replies matched by:
  1. `In-Reply-To` header → lookup original message
  2. Parse `[THD-xxx]` from subject
  3. Watermark/token in body (fallback)

**Security:**
- Tokens in thread references prevent guessing
- SPF/DKIM/DMARC verify sending domain
- New threads can require known contacts only

### 6. Custom Domain Support (Multi-tenant)

**Decision:** Support customers using their own email domains.

**Requirements per customer:**
- MX record pointing to email provider
- SPF record authorizing provider
- DKIM CNAME for signatures
- Domain verification in provider

**Implementation:**
- Tenant identification via `To` address on inbound
- Outbound sends `From` customer's domain
- Database scoped by tenant

**Recommendation:** Start with single domain, add custom domains as premium feature.

### 7. No AI Intermediary for Email

**Decision:** Email gateway has no AI processing. Raw email → thread storage.

**The MCP is the bridge:**
- Agents read threads via MCP
- Agents create/update internal tickets
- Agents write replies to threads
- MCP handles the mapping, not the email gateway

### 8. Agent Reply Method: Native Email Client + Add-on (UPDATED)

**Decision:** Agents use their normal Gmail/Outlook email clients. A browser add-on appends thread IDs to outbound emails.

**Rationale:**
- Agents stay in familiar tools (Gmail, Outlook)
- No need to build a compose UI in Tisket
- Lower friction for adoption
- Tisket becomes read-only for threads internally (view conversations, link to tickets)

**Rejected alternative:**
- Agents compose replies within Tisket UI → Tisket sends email on their behalf
- This would require building email composition, formatting, attachments, etc.

---

## Add-on Architecture (Gmail / Outlook)

### Option A: Gmail Add-on (Recommended for Gmail users)

**Pros:**
- Official Google Apps Script API with `UpdateDraftSubjectAction`
- Works across devices (desktop, mobile Gmail app) when signed into account
- Sandboxed, stable, won't break when Gmail updates UI
- Compose trigger hooks into email composition natively
- Can modify subject, body, recipients via official APIs

**Cons:**
- Requires Google Workspace Marketplace publishing (or internal deployment)
- Apps Script has some latency
- Limited to Gmail users

**Implementation:**
- Define `gmail.composeTrigger` in manifest
- On compose, query Tisket API: "is there a thread for this recipient/subject?"
- If match found, use `UpdateDraftSubjectAction` to append `[THD-xxx]`
- Store Message-ID mapping when email is sent

### Option B: Chrome Extension (Alternative for Gmail)

**Pros:**
- More flexibility (full DOM access)
- Can work on any webmail, not just Gmail
- No marketplace approval needed for internal use

**Cons:**
- Fragile - Gmail DOM changes frequently, requires maintenance
- Desktop browser only (no mobile)
- No official API, relies on reverse-engineering
- Only works in browser where installed

**Not recommended** due to maintenance burden.

### Option C: Outlook Web Add-in (Recommended for Outlook users)

**Pros:**
- Official Microsoft API with compose mode support
- Works across platforms (new Outlook, web, Mac)
- Microsoft phasing out COM add-ins, web add-ins are the future
- Sandboxed, stable
- Easy deployment (no per-machine install)

**Cons:**
- Different codebase from Gmail Add-on
- Requires Microsoft Partner Center for public distribution

**Implementation:**
- Define compose mode activation in manifest
- Hook into compose events
- Query Tisket API for thread matching
- Modify subject field via Office.js API

### Recommendation

Build both **Gmail Add-on** and **Outlook Web Add-in** using their official APIs. Share the Tisket API integration logic, keep platform-specific code separate.

---

## Revised Architecture Diagram

```
CLIENT SIDE (External)

  Client        Thread Storage       Email Provider
  (Email)       (Database, HTML)     (Postmark, SendGrid)
     │                │                    │
     └────────────────┼────────────────────┘
                      │
              Email Gateway (Webhooks)
                      │
                      ▼
               Inbound Processing
               (Create/update threads)
```

```
PROVIDER SIDE (Internal)

  Agent Email Client              Tisket
  (Gmail / Outlook)                 │
        │                           │
        │ ◄── Add-on queries ──────►│ Thread API
        │     for thread match      │
        │                           │
        ▼                           │
  Outbound Email ──────────────────►│ Inbound webhook
  (with [THD-xxx] in subject)       │ (matches to thread)
                                    │
                                    ▼
                             Thread Storage
                                    │
  Agent in Tisket UI ◄──────────────┘
  (read-only thread view,
   link to internal tickets)
```

```
INTERNAL TICKETING (Unchanged)

  Agent ◄────▶ MCP ◄────▶ .tickets repo (git)
                │
                │ reads threads (read-only)
                ▼
         Thread Storage
```

---

## Data Model

### Threads (Database)

```sql
CREATE TABLE tenants (
  id              TEXT PRIMARY KEY,
  name            TEXT,
  inbound_domain  TEXT UNIQUE,   -- support.clientcorp.com
  outbound_domain TEXT           -- clientcorp.com
);

CREATE TABLE threads (
  id            TEXT PRIMARY KEY,   -- THD-001
  tenant_id     TEXT REFERENCES tenants(id),
  subject       TEXT,
  status        TEXT,               -- open, in_progress, resolved, closed
  client_email  TEXT,
  client_name   TEXT,
  created_at    TIMESTAMP,
  updated_at    TIMESTAMP
);

CREATE TABLE messages (
  id            TEXT PRIMARY KEY,
  thread_id     TEXT REFERENCES threads(id),
  message_id    TEXT,               -- Email Message-ID header
  direction     TEXT,               -- inbound, outbound
  from_address  TEXT,
  body_html     TEXT,
  created_at    TIMESTAMP
);

CREATE TABLE attachments (
  id            TEXT PRIMARY KEY,
  message_id    TEXT REFERENCES messages(id),
  filename      TEXT,
  content_type  TEXT,
  storage_path  TEXT                -- S3/R2 path
);
```

### Internal Ticket Link

```yaml
# In engineering.tickets/TKT-042.md
---
status: in_progress
priority: high
assignee: "@sarah"
client_thread:
  tenant: clientcorp
  thread_id: THD-001
---
```

---

## MCP Tools Needed

```typescript
// Thread operations (read-only for agents)
list_threads(tenant_id, status?)
get_thread(thread_id)
update_thread_status(thread_id, status)

// Linking
link_thread_to_ticket(thread_id, ticket_id)
get_ticket_for_thread(thread_id)

// Add-on API (called by Gmail/Outlook add-on)
find_thread_for_email(recipient_email, subject, in_reply_to?)
// Returns thread_id if match found, null otherwise
```

**Note:** `reply_to_thread()` removed - agents reply via their email client, not MCP.

---

## Implementation Phases

### Phase 1: Core Email Gateway
- Webhook endpoint for inbound email
- Thread/message storage (database)
- Basic threading (subject line + header parsing)
- Thread API for add-on queries

### Phase 2: Gmail/Outlook Add-ons
- Gmail Add-on (Apps Script)
- Outlook Web Add-in (Office.js)
- Thread lookup API integration
- Subject line injection on compose

### Phase 3: Tisket Thread Viewer
- Internal tab to view threads (read-only)
- Link threads to internal tickets
- Filter by status, tenant, date

### Phase 4: Multi-tenant / Custom Domains
- Per-tenant configuration
- Custom domain onboarding flow
- Domain verification

### ~~Phase 3: Client Portal (Deprioritized)~~
~~- Web UI for clients to view their threads~~
~~- Direct message submission (no email)~~
~~- File upload/download~~

**Note:** Client portal deprioritized. Clients use email. Internal team views threads in Tisket.

---

## Open Questions

1. **Attachment storage:** S3/R2 vs database blobs?
2. ~~**Thread portal:** Build custom or use existing solution?~~ → Deprioritized
3. **Real-time:** WebSockets for live thread updates in Tisket viewer?
4. **Email provider:** Postmark vs SendGrid vs others?
5. **Add-on distribution:** Internal only, or publish to marketplaces?

---

## References

- ServiceNow email threading model
- [Gmail Add-ons Compose UI](https://developers.google.com/apps-script/add-ons/gmail/extending-compose-ui)
- [Outlook Add-ins Overview](https://learn.microsoft.com/en-us/office/dev/add-ins/outlook/outlook-add-ins-overview)
- [Outlook Compose Add-ins](https://learn.microsoft.com/en-us/office/dev/add-ins/outlook/compose-scenario)
- Postmark inbound webhook documentation
