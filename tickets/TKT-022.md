---
status: resolved
priority: medium
created: 2026-01-26
resolved: 2026-01-26
---
# TKT-022: Remove REST API write path from client - use MCP git push

## Implementation (Completed)

Implemented **Option A** - all client writes now route through MCP.

### Changes Made

| File | Change |
|------|--------|
| `client/src/lib/mcp-client.ts` | **NEW** - Server-side MCP client helper |
| `client/src/trpc/routers/repos.ts` | Migrated 4 procedures to use MCP tools |
| `client/src/lib/github.ts` | Removed `updateFileContent` function |

### Migrated Procedures

| Procedure | MCP Tool | Notes |
|-----------|----------|-------|
| `updateTicketStatus` | `update_ticket` | MCP handles read/modify/write |
| `updateBoardContent` | `write` | Direct file write |
| `updateBacklogOrder` | `write` | Still reads first to preserve YAML structure |
| `addTicketToSprint` | `add_to_board` | MCP handles read/modify/write |

### Architecture

```
Browser → tRPC (server) → MCP server → git commit → git push
```

The tRPC procedures call MCP directly (no proxy route needed). Auth token is obtained via `getAuth()` in the MCP client helper.

### What Was NOT Implemented

- No `/api/mcp` proxy route - server-side code calls MCP directly
- No browser-side MCP client - all writes go through tRPC

---

## Summary

The client has two write paths that should be consolidated:
1. **Client tRPC** → REST API `PUT /repos/.../contents/...` (current)
2. **MCP server** → git commit + push (correct approach)

All writes should go through MCP's git push for consistency.

## Current State

`client/src/trpc/routers/repos.ts` uses `updateFileContent()` which:
1. Calls `GET /repos/{org}/{repo}/contents/{path}` to get current SHA
2. Calls `PUT /repos/{org}/{repo}/contents/{path}` to write

This is used for:
- Board updates (lines 390, 415)
- File writes (lines 529, 566)

## MCP Approach (Correct)

MCP server (`mcp/src/operations/`) does:
1. `fs.writeFile()` to local clone
2. `git.commit()` 
3. `git.push()`

This is better because:
- Uses git protocol (separate rate limits from REST API)
- Consistent with the "git as source of truth" architecture
- Proper commit history with author attribution
- SSE events already work with this flow

## Implementation Options

### Option A: Route writes through MCP (Recommended)

**How it works:**
Client tRPC → MCP HTTP endpoint → MCP writes to local clone → git commit → git push

**Pros:**
- Single source of truth for write logic
- MCP already handles SSE events for realtime updates
- Proper commit authorship (MCP knows user context)
- Works for Claude Code and web client identically
- Minimal new code - just wire tRPC to existing MCP endpoints

**Cons:**
- Extra network hop (client → server → MCP → GitHub)
- MCP must be running/reachable for web client writes
- Latency: ~200-500ms added vs direct API

**Implementation:**
1. Delete `updateFileContent` from `client/src/lib/github.ts`
2. Add tRPC procedure that calls MCP's existing write endpoint
3. Done - no new logic, just wiring

---

### Option B: Client-side git push (isomorphic-git)

**How it works:**
Browser isomorphic-git → write to IndexedDB clone → git commit → git push via `/api/git/` proxy → GitHub

**Pros:**
- Writes happen locally first (optimistic, fast UI)
- Works offline (commit locally, push when online)
- Browser git clone stays in sync automatically
- No MCP dependency for web client
- True "local-first" architecture

**Cons:**
- Need to implement git push auth - `/api/git/` proxy needs write credentials
- Commit authorship - browser needs user's git identity configured
- Duplicate write logic - MCP and browser both have implementations
- More complex conflict handling (see below)

---

### Option C: Hybrid (simple writes client-side, complex through MCP)

**Pros:**
- Fast path for common operations
- MCP for complex orchestration

**Cons - significantly more complex:**
- Two write paths to implement and maintain
- Decision logic needed: "is this simple or complex?"
- Edge cases: what if a "simple" write fails and needs retry through MCP?
- Testing burden: need to test both paths, plus handoff between them
- State sync: browser git clone and MCP clone could diverge
- Bugs where one path works, other doesn't - hard to reproduce
- Unclear benefit over committing to A or B

---

## Conflict Handling

Conflicts can happen with any approach - the question is where you handle them.

**Option A (MCP):**
- Conflict handling centralized on server
- MCP can fetch, detect conflict, auto-rebase or return error
- Client shows simple "conflict, please refresh" message
- One implementation to maintain

**Option B (Browser):**
- Conflict handling in browser JavaScript
- Need UI for "conflict detected, pull changes?"
- Can't easily do server-side auto-rebase
- Same complexity as A, but duplicated in browser

**Option C:**
- Conflict handling in both places
- Need to handle conflicts differently depending on which path was used
- Most complex

## Recommendation

**Start with Option A** because:
1. MCP write logic already exists and works
2. Simplest to implement (remove client code, wire to MCP)
3. SSE realtime updates already connected
4. Centralized conflict handling
5. Can evolve to Option B later if offline/latency becomes important

## Related

- TKT-021: GitHub App evaluation (this fix reduces REST API dependency)
- TKT-023: DB as source of truth for repos
- CLAUDE.md architecture guidelines

## Comments

**2026-01-26** — *Claude*

## Expanded Tradeoffs for Write Approaches

### Option A: Route writes through MCP server

**How it works:**
Client tRPC → MCP HTTP endpoint → MCP writes to local clone → git commit → git push

**Pros:**
- Single source of truth for write logic
- MCP already handles SSE events for realtime updates
- Proper commit authorship (MCP knows user context)
- Works for Claude Code and web client identically
- No new code in client - just call existing MCP endpoints

**Cons:**
- Extra network hop (client → server → MCP → GitHub)
- MCP must be running/reachable for web client writes
- Latency: ~200-500ms added vs direct GitHub API
- Coupling: web client depends on MCP availability

**Best for:** Simpler architecture, consistency with Claude Code usage

---

### Option B: Client-side git push (isomorphic-git)

**How it works:**
Browser isomorphic-git → write to IndexedDB clone → git commit → git push via `/api/git/` proxy → GitHub

**Pros:**
- Writes happen locally first (optimistic, fast UI)
- Works offline (commit locally, push when online)
- Browser git clone stays in sync automatically
- No MCP dependency for web client
- True "local-first" architecture

**Cons:**
- Need to implement git push in browser (auth token handling)
- Merge conflicts more complex to handle client-side
- Duplicate write logic (client + MCP both need it)
- `/api/git/` proxy needs to handle push auth
- Commit authorship: need user's git identity in browser

**Best for:** Local-first UX, offline support, independence from MCP

---

### Option C: Hybrid approach

**How it works:**
- Simple writes (single file): client-side git push
- Complex operations (multi-file, migrations): route through MCP

**Pros:**
- Fast path for common operations
- MCP for complex orchestration
- Flexibility

**Cons:**
- Most complex to implement and maintain
- Two code paths to test
- Inconsistent behavior possible

---

## Recommendation

**Start with Option A (MCP routing)** because:
1. MCP write logic already exists and works
2. Simpler to implement (remove client code, add tRPC→MCP calls)
3. SSE realtime updates already wired up
4. Can evolve to Option B later if offline/latency matters

Option B is better long-term for a true local-first app, but Option A gets consistency now with minimal effort.
